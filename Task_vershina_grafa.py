#Задача с изображением графа. Есть несколько вершин многоугольника. Многоугольник состоит из вершин (они пронумерованы
#от 1 до 6, и у всех них есть грани. Для каждой из двух вершин есть общая линия(ребро) и мы можем узнать, какой оно длины
#Нужно найти кратчайший путь из одной точки (вершины) в другую - т.е. найти суммарную минимальную
#длину ребер. При решении задачи воспользуемся алгоритмом Дейкстры
#Нужно найти кратчайший путь из вершины 2 в вершины 1, 3, 6 (во все вершины)


#Решение:
#Запишем наш граф в виде словаря. Все вершины мы храним в словаре, у каждой вершины будет свой отдельный словарь,
# в котором мы будем хранить кратчайшие расстояния от одной вершины до другой



Graf = {
    1 : {#Единица соединена с вершинами 2, 3 и 6
        2 : 7,
        3 : 9,
        6 : 14
    },

    2 : {
        1 : 7,
        3 : 10,
    },

    3 : {
        1 : 9,
        2 : 10,
        6: 3
    },
    6 : {
        1 : 14,
        3 : 3
    }
}


#Задаем вершину 2 в качестве старта
start = 2

# Для реализации алгоритма нужно записать все расстояния в отдельный словарь
# Изначально нужно записать в словарь бесконечно большие расстояния для корректной работы алгоритма
#Например, для ключа i расстояние будет 1000 до вершит 1, 2, 3, 6 (всех, которые рассматриваем в задаче)
#2 тоже пишем, т.к. это наш старт

#Пусть все наши вершины будут записаны в словарь. Все вершины это ключи словаря Graf.
#G.keys() = [1, 2, 3, 6] - это мы не пишем, т.к. вершины и так мы уже определили в словаре Граф.
#Будем далее писать просто G.keys

Distance = { i : 1000 for i in Graf.keys() }
Distance[start] = 0#расстояние до старта равно 0, т.к. мы находимся на старте

#Теперь нужно завести словарь, в который будем записывать, в каких вершинах уже были, а в каких еще нет
#Пока никакие вершины не посетили, храним в словаре False
Use_vershin = { i : False for i in Graf.keys() }

#Перечислили все вершины, которые участвуют в решении задачи, указали расстояние между вершинами,
#проверили, были в вершинах или нет. Теперь нужно узнать вершину, до которой расстояние минимально от исходной точки
#На первой итерации расстояние из исходной точки до самой себя будет 0. Потом перебираем  все соседние вершины
#и проверяем расстояния. До этого мы специально вносили в словарь значение 1000, которое сильно больше всех расстояний,
#которые могут быть в задаче, чтобы сравнивать другие расстояния с этим числом. Если наше расстояние меньше 1000, то мы его
#записываем в словарь с расстояниями Distance. Далее берем расстояние до другой вершины, если оно оказалось меньше значения,
#записанного в словарь, то мы перезаписываем значение в словаре - получаем меньшее расстояние.

#Когда посетим все вершины - получим все значения расстояний и сможем посчитать все короткие пути

#Алгоритм:
#Итераций будет столько же, сколько и вершин, потому что на каждой итерации посещаем одну из вершин
#И нужно выбрать вершину с минимальным расстоянием

for _ in range(len(Graf.keys())):#4 итерации, можно узнать также, если посчитать кол-во вершин в словаре - т.е. кол-во ключей в Graf
#теперпь выбираем вершины с меньшими расстояниями
#В ключах Use_vershin мы хранили значение False, если вершину не посещали
    candidates = [k for k in Use_vershin.keys() if not Use_vershin[k]]


#Разбираем строчку выше
#Заводим список candidates (кандидаты на минимум) и храним там вершины, которые мы еще не посетили
#Перебираем переменной k все ключи словаря Use_vershin вот таким образом k for k in Use_vershin.keys()
#с условием, что мы их еще не посетили - if not Use_vershin[k] т.е. когда в словаре Use_vershin записано значение False

#Далее из списка candidates (кандидаты на минимум) выбираем кандидата с минимальным расстоянием от старта до вершины

    min_k = min(candidates, key=lambda x : Distance[x] )
#функция min имеет в первом аргументе вершину, а во втором аргументе принимает аргумент key
#Это нужно, чтобы принимать не значения из списка, а значения списка с необходимым параметром
# (нам нужно найти объект с минимальным параметром расстояние), поэтому в качестве ключа key мы передаем
# наш параметр. Этот параметр задаем функцией, которая для каждого элемента списка этот параметр возвращает

#key=lambda x : Distance[x] это значит, что для каждой вершины х мы возвращаем расстояние от старта до х
#Пишем параметр через lambda - получаем значение с минимальным расстоянием
#НЕ пишем параметр через lambda - получаем инимальное значение по номеру списка

#Тепепь нужно обойти все соседние вершины. Маршрут из точки 2 в точку 3 получили.
# Чтобы найти маршрут из точки 2 в точку 6, нужно рассмотреть продолжение маршрута и посмотреть соседние маршруты(расстояния)
#Для каждой вершины смотрим соседнюю с ней вершину (они у нас хранятся в словаре Graf)
#Graf = {
    #1 : {#Единица соединена с вершинами 2, 3 и 6
        #2 : 7,
        #3 : 9,
        #6 : 14
    #},

    for vershina, dlina_rebra in Graf[min_k].items():#Смотрим вершину и расстояние от нее в другую вершину (ребро)
        if Distance[vershina] > Distance[min_k] + dlina_rebra:
            #Допустим, минимум из точки в 2 в точку 1 = 7 и мы хотим попасть в точку 6, то мы находимся в точке 1
            #Если расстояние до вершины 6 из точки 1  равно 14 , то из точки 2 в точку 6 расстояние равно 7+14 = 21
            #и есть другое расстояние до вершины 6 через 2 другие вершины.
            #из точки 1 в точку 3 расстояние равно 9 и из точки 3 в точку 6 расстояние равно 3, то 7+9+3=19 короче
            Distance[vershina] = Distance[min_k] + dlina_rebra


#Graf[min_k].keys - Для полученной ранее вершины min_k с минимальным расстоянием, смотрим соседние вершины в словаре Graf[min_k]
#и расстояния для этих вершин - keys
#Тогда Graf[min_k].items - это сразу посчитанный минимум

    Use_vershin[min_k] = True

print(Distance)







